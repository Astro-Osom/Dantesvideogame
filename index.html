<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Dante & Coco">
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="Dante_App_Logo.png">
    <title>Dante and Coco Save the Day</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a2e;
            overflow: hidden;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            position: fixed;
            width: 100%;
            height: 100%;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }
        #game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }
        canvas { display: block; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
<div id="game-container"></div>
<script>
/******************************************************************************
 * DANTE AND COCO SAVE THE DAY â€” PHASE 1 BUILD
 * Art Direction: Super Mario Bros 2 structure meets Pandora bioluminescence
 * Engine: Phaser 3.60 | Target: iPad/iPhone Safari PWA
 ******************************************************************************/

// ============================================================================
// CONSTANTS & CONFIGURATION
// ============================================================================
const W = 960, H = 540;
const GRAVITY = 1100;
const WORLD_WIDTH = 4800;

const DIFFICULTY = {
    easy:   { tokensNeeded: 10, tokenCount: 30, henchSpeed: 80,  dayTime: 300, bossHP: 6,  tokenTimeBonus: 3, bossAtkSpeed: 0.6 },
    normal: { tokensNeeded: 20, tokenCount: 28, henchSpeed: 130, dayTime: 210, bossHP: 10, tokenTimeBonus: 2, bossAtkSpeed: 1.0 },
    hard:   { tokensNeeded: 25, tokenCount: 25, henchSpeed: 180, dayTime: 150, bossHP: 14, tokenTimeBonus: 1, bossAtkSpeed: 1.4 }
};

const COLORS = {
    pandoraDark:    0x0a0a2e,
    pandoraDeep:    0x0d1b3e,
    pandoraMid:     0x1a3a5c,
    neonCyan:       0x00ffee,
    neonMagenta:    0xff00cc,
    neonGold:       0xffdd44,
    bioGreen:       0x44ffaa,
    bioBlue:        0x22aaff,
    bioPurple:      0xaa44ff,
    heartRed:       0xff3366,
    groundGreen:    0x0d4a3a,
    groundGlow:     0x22ffaa,
    platformTeal:   0x1a6b5a,
    platformGlow:   0x44ffcc,
    danteBlue:      0x4488ff,
    cocoPink:       0xff66aa,
    ghostWhite:     0xccddff,
    tokenGold:      0xffcc00,
    portalSwirl:    0x8844ff,
    white:          0xffffff,
    black:          0x000000,
    uiDark:         0x111133
};

// Level data for all 5 worlds
const LEVELS = [
    { name: "Rainbow Meadow",   skyTop: '#0d1b4a', skyBot: '#1a4a3a', ground: COLORS.groundGreen,  groundGlow: COLORS.bioGreen,  platform: COLORS.platformTeal, platGlow: COLORS.platformGlow, henchKey: 'ghost',   bossKey: 'boss1', henchColor: COLORS.ghostWhite, bioAccent: COLORS.neonCyan },
    { name: "Sky Ranch",        skyTop: '#1a0a3e', skyBot: '#3a1a5a', ground: 0x2a1a4a,           groundGlow: COLORS.bioPurple, platform: 0x3a2a5a,           platGlow: COLORS.bioPurple,    henchKey: ['horse','cattle'], bossKey: 'boss2', henchColor: 0xaa8844, bioAccent: COLORS.bioPurple },
    { name: "Volcano Factory",  skyTop: '#2a0a0a', skyBot: '#4a1a0a', ground: 0x1a0a0a,           groundGlow: 0xff4422,         platform: 0x3a1a0a,           platGlow: 0xff6633,            henchKey: 'piranha', bossKey: 'boss3', henchColor: 0xff4422,          bioAccent: 0xff6633 },
    { name: "Shadow Realm",     skyTop: '#050510', skyBot: '#0a0a1a', ground: 0x0a0a15,           groundGlow: 0x4444aa,         platform: 0x151530,           platGlow: 0x6666cc,            henchKey: 'monkey',  bossKey: 'boss4', henchColor: 0x886644,          bioAccent: 0x6666ff },
    { name: "Dream Club",       skyTop: '#1a0a3a', skyBot: '#0a2a3a', ground: 0x2a1a4a,           groundGlow: COLORS.neonMagenta, platform: 0x3a2a5a,         platGlow: COLORS.neonGold,     henchKey: 'unicorn', bossKey: 'boss5', henchColor: 0xffffff,          bioAccent: COLORS.neonMagenta }
];

// ============================================================================
// SPRITE SIZE HELPER â€” stores base scales so animations can be relative
// ============================================================================
function initSize(sprite, w, h) {
    sprite.setDisplaySize(w, h);
    sprite._bsx = sprite.scaleX;
    sprite._bsy = sprite.scaleY;
    return sprite;
}

// ============================================================================
// SAVE SYSTEM
// ============================================================================
class SaveManager {
    static SAVE_KEY = 'dante_coco_saves';

    static getSlots() {
        try {
            const data = localStorage.getItem(this.SAVE_KEY);
            return data ? JSON.parse(data) : [null, null, null];
        } catch { return [null, null, null]; }
    }

    static save(slotIndex, gameState) {
        const slots = this.getSlots();
        slots[slotIndex] = {
            ...gameState,
            timestamp: Date.now()
        };
        try { localStorage.setItem(this.SAVE_KEY, JSON.stringify(slots)); } catch {}
    }

    static load(slotIndex) {
        return this.getSlots()[slotIndex];
    }

    static delete(slotIndex) {
        const slots = this.getSlots();
        slots[slotIndex] = null;
        try { localStorage.setItem(this.SAVE_KEY, JSON.stringify(slots)); } catch {}
    }
}

// ============================================================================
// GAME STATE (shared across scenes)
// ============================================================================
const GameState = {
    currentLevel: 0,
    tokens: 0,
    hearts: 3,
    maxHearts: 3,
    daylight: 100,
    activeChar: 'dante',
    difficulty: 'easy',
    saveSlot: 0,
    checkpointX: 100,
    completedWorlds: [],
    tutorialDone: false,
    secretRoomVisited: false,
    deathsInSection: 0,

    getDifficulty() { return DIFFICULTY[this.difficulty]; },

    reset() {
        this.currentLevel = 0;
        this.tokens = 0;
        this.hearts = 3;
        this.maxHearts = 3;
        this.daylight = 100;
        this.activeChar = 'dante';
        this.checkpointX = 100;
        this.completedWorlds = [];
        this.tutorialDone = false;
        this.secretRoomVisited = false;
        this.deathsInSection = 0;
    },

    toSaveData() {
        return {
            currentLevel: this.currentLevel,
            tokens: this.tokens,
            hearts: this.hearts,
            maxHearts: this.maxHearts,
            daylight: this.daylight,
            activeChar: this.activeChar,
            difficulty: this.difficulty,
            checkpointX: this.checkpointX,
            completedWorlds: [...this.completedWorlds],
            tutorialDone: this.tutorialDone
        };
    },

    fromSaveData(data) {
        Object.assign(this, data);
    }
};

// ============================================================================
// PROCEDURAL PIXEL ART GENERATOR
// Art Style: SMB2 proportions + Pandora bioluminescence
// ============================================================================
class PixelArt {
    static generateAll(scene) {
        this.makeCharacter(scene, 'dante', COLORS.danteBlue, 0x2244aa, 0xffcc88);
        this.makeCharacter(scene, 'coco', COLORS.cocoPink, 0xcc4488, 0x8b5e3c);
        this.makeToken(scene);
        this.makeHeart(scene);
        this.makeCheckpoint(scene);
        this.makeGhost(scene);
        this.makeHorse(scene);
        this.makePiranha(scene);
        this.makeMonkey(scene);
        this.makeUnicorn(scene);
        this.makeBoss(scene, 'boss1', 0xffcc00, 0xaa8800);
        this.makeBoss(scene, 'boss2', 0x8B4513, 0x654321);
        this.makeBoss(scene, 'boss3', 0xff4422, 0xcc2200);
        this.makeBoss(scene, 'boss4', 0x556b2f, 0x3a4a1f);
        this.makeBoss(scene, 'boss5', 0xff66aa, 0xcc4488);
        this.makeWizard(scene);
        this.makeFairy(scene);
        this.makeTim(scene);
        this.makeParticle(scene);
        this.makeStar(scene);
        this.makeJoystickBase(scene);
        this.makeJoystickThumb(scene);
        this.makePortal(scene);
    }

    static makeCharacter(scene, key, bodyColor, darkColor, skinColor) {
        const g = scene.make.graphics({ add: false });
        // SMB2-style proportions: big head, compact body (32x48)
        // Head (slightly oversized)
        g.fillStyle(skinColor); g.fillRect(8, 0, 16, 14);
        // Hair
        g.fillStyle(darkColor); g.fillRect(8, 0, 16, 5);
        // Eyes
        g.fillStyle(0xffffff); g.fillRect(11, 6, 4, 4); g.fillRect(18, 6, 4, 4);
        g.fillStyle(0x222222); g.fillRect(13, 7, 2, 3); g.fillRect(20, 7, 2, 3);
        // Body
        g.fillStyle(bodyColor); g.fillRect(8, 14, 16, 16);
        // Bio-luminescent markings (Pandora-style)
        g.fillStyle(COLORS.neonCyan, 0.7);
        g.fillRect(10, 16, 2, 8); g.fillRect(20, 16, 2, 8);
        // Arms
        g.fillStyle(bodyColor); g.fillRect(4, 16, 4, 12); g.fillRect(24, 16, 4, 12);
        // Hands
        g.fillStyle(skinColor); g.fillRect(4, 26, 4, 4); g.fillRect(24, 26, 4, 4);
        // Legs
        g.fillStyle(darkColor); g.fillRect(10, 30, 5, 14); g.fillRect(17, 30, 5, 14);
        // Shoes
        g.fillStyle(bodyColor === COLORS.danteBlue ? 0x3366cc : 0xcc3388);
        g.fillRect(8, 40, 7, 6); g.fillRect(17, 40, 7, 6);
        // Glow outline (so characters never get lost in bioluminescent scenery)
        g.generateTexture(key, 32, 48);
        g.destroy();
    }

    static makeToken(scene) {
        const g = scene.make.graphics({ add: false });
        g.fillStyle(COLORS.tokenGold);
        g.fillCircle(10, 10, 9);
        g.fillStyle(0xffee88);
        g.fillCircle(10, 9, 6);
        g.fillStyle(COLORS.tokenGold);
        g.fillRect(8, 6, 5, 8);
        g.generateTexture('token', 20, 20);
        g.destroy();
    }

    static makeHeart(scene) {
        const g = scene.make.graphics({ add: false });
        g.fillStyle(COLORS.heartRed);
        g.fillCircle(7, 6, 6); g.fillCircle(17, 6, 6);
        g.fillTriangle(1, 8, 23, 8, 12, 22);
        g.generateTexture('heart', 24, 24);
        g.destroy();
    }

    static makeCheckpoint(scene) {
        const g = scene.make.graphics({ add: false });
        g.fillStyle(0x888888); g.fillRect(6, 0, 4, 40);
        g.fillStyle(COLORS.neonCyan); g.fillTriangle(10, 2, 10, 18, 28, 10);
        g.generateTexture('checkpoint', 30, 40);
        g.destroy();
    }

    static makeGhost(scene) {
        const g = scene.make.graphics({ add: false });
        g.fillStyle(COLORS.ghostWhite, 0.7);
        g.fillCircle(16, 12, 12);
        g.fillRect(4, 12, 24, 16);
        // Wavy bottom
        g.fillCircle(8, 28, 4); g.fillCircle(16, 28, 4); g.fillCircle(24, 28, 4);
        // Eyes
        g.fillStyle(0x4444ff); g.fillCircle(11, 10, 3); g.fillCircle(21, 10, 3);
        g.fillStyle(0x000033); g.fillCircle(12, 10, 1.5); g.fillCircle(22, 10, 1.5);
        // Bio glow spots
        g.fillStyle(COLORS.neonCyan, 0.4);
        g.fillCircle(16, 18, 3);
        g.generateTexture('ghost', 32, 32);
        g.destroy();
    }

    static makeHorse(scene) {
        const g = scene.make.graphics({ add: false });
        g.fillStyle(0x8B4513);
        // Body
        g.fillRect(6, 10, 22, 12);
        // Head
        g.fillRect(0, 4, 10, 12);
        // Legs
        g.fillRect(8, 22, 4, 10); g.fillRect(22, 22, 4, 10);
        // Eye
        g.fillStyle(0xffffff); g.fillCircle(4, 8, 2);
        g.fillStyle(0x000000); g.fillCircle(4, 8, 1);
        // Mane glow
        g.fillStyle(COLORS.bioPurple, 0.6);
        g.fillRect(10, 6, 12, 3);
        g.generateTexture('horse', 32, 32);
        g.destroy();
    }

    static makePiranha(scene) {
        const g = scene.make.graphics({ add: false });
        g.fillStyle(0xff4422);
        // Body
        g.fillCircle(16, 16, 10);
        // Tail
        g.fillTriangle(24, 12, 32, 6, 32, 26);
        // Eye
        g.fillStyle(0xffffff); g.fillCircle(10, 13, 3);
        g.fillStyle(0x000000); g.fillCircle(10, 13, 1.5);
        // Teeth
        g.fillStyle(0xffffff);
        g.fillTriangle(6, 18, 8, 23, 10, 18);
        g.fillTriangle(10, 18, 12, 23, 14, 18);
        // Glow
        g.fillStyle(0xff6633, 0.4);
        g.fillCircle(16, 16, 5);
        g.generateTexture('piranha', 32, 32);
        g.destroy();
    }

    static makeMonkey(scene) {
        const g = scene.make.graphics({ add: false });
        g.fillStyle(0x886644);
        // Body
        g.fillCircle(16, 14, 10);
        g.fillRect(10, 14, 12, 10);
        // Arms
        g.fillRect(4, 12, 6, 4); g.fillRect(22, 12, 6, 4);
        // Face
        g.fillStyle(0xccaa88); g.fillCircle(16, 12, 6);
        // Eyes (glowing)
        g.fillStyle(COLORS.neonCyan); g.fillCircle(13, 11, 2); g.fillCircle(19, 11, 2);
        g.fillStyle(0x000000); g.fillCircle(13, 11, 1); g.fillCircle(19, 11, 1);
        // Tail
        g.lineStyle(2, 0x886644);
        g.lineBetween(16, 24, 28, 28);
        g.generateTexture('monkey', 32, 32);
        g.destroy();
    }

    static makeUnicorn(scene) {
        const g = scene.make.graphics({ add: false });
        g.fillStyle(0xffffff);
        // Body
        g.fillRect(6, 12, 20, 10);
        // Head
        g.fillRect(0, 6, 10, 10);
        // Horn (rainbow glow)
        g.fillStyle(COLORS.neonGold); g.fillTriangle(3, 6, 5, -4, 7, 6);
        // Legs
        g.fillStyle(0xffffff);
        g.fillRect(8, 22, 3, 8); g.fillRect(21, 22, 3, 8);
        // Mane (rainbow)
        g.fillStyle(COLORS.neonMagenta, 0.6); g.fillRect(10, 8, 8, 3);
        g.fillStyle(COLORS.neonCyan, 0.6); g.fillRect(12, 5, 6, 3);
        // Eye
        g.fillStyle(COLORS.bioPurple); g.fillCircle(4, 10, 2);
        g.generateTexture('unicorn', 32, 32);
        g.destroy();
    }

    static makeBoss(scene, key, mainColor, darkColor) {
        const g = scene.make.graphics({ add: false });
        // Larger sprite: 48x56 (SMB2 boss scale)
        g.fillStyle(mainColor);
        g.fillCircle(24, 14, 14); // Head
        g.fillRect(10, 14, 28, 24); // Body
        // Eyes (menacing)
        g.fillStyle(0xff0000); g.fillCircle(18, 12, 3); g.fillCircle(30, 12, 3);
        g.fillStyle(0xffff00); g.fillCircle(18, 12, 1.5); g.fillCircle(30, 12, 1.5);
        // Body detail
        g.fillStyle(darkColor); g.fillRect(14, 20, 20, 4);
        // Legs
        g.fillStyle(mainColor);
        g.fillRect(14, 38, 6, 14); g.fillRect(28, 38, 6, 14);
        // Bio glow accents
        g.fillStyle(COLORS.neonCyan, 0.4);
        g.fillRect(12, 26, 2, 10); g.fillRect(34, 26, 2, 10);
        g.generateTexture(key, 48, 56);
        g.destroy();
    }

    static makeWizard(scene) {
        const g = scene.make.graphics({ add: false });
        // Robe
        g.fillStyle(0x4422aa);
        g.fillTriangle(16, 8, 2, 44, 30, 44);
        // Hat
        g.fillStyle(0x5533cc);
        g.fillTriangle(10, 12, 16, -6, 22, 12);
        // Face
        g.fillStyle(0xddbb99); g.fillRect(10, 12, 12, 10);
        // Eyes
        g.fillStyle(0x4488ff); g.fillCircle(13, 16, 2); g.fillCircle(19, 16, 2);
        // Beard
        g.fillStyle(0xcccccc); g.fillTriangle(10, 22, 22, 22, 16, 36);
        // Staff glow
        g.fillStyle(COLORS.bioPurple, 0.6);
        g.fillCircle(28, 10, 4);
        g.fillStyle(0x886644); g.fillRect(27, 14, 2, 30);
        g.generateTexture('wizard', 32, 48);
        g.destroy();
    }

    static makeFairy(scene) {
        const g = scene.make.graphics({ add: false });
        // Wings
        g.fillStyle(COLORS.neonCyan, 0.4);
        g.fillCircle(6, 14, 8); g.fillCircle(26, 14, 8);
        // Body
        g.fillStyle(0xffccee);
        g.fillCircle(16, 14, 6);
        g.fillTriangle(12, 18, 20, 18, 16, 32);
        // Face
        g.fillStyle(0xffddb3); g.fillCircle(16, 12, 5);
        // Crown
        g.fillStyle(COLORS.neonGold);
        g.fillTriangle(12, 8, 14, 3, 16, 8);
        g.fillTriangle(16, 8, 18, 3, 20, 8);
        // Wand
        g.fillStyle(COLORS.neonGold); g.fillRect(22, 10, 2, 16);
        g.fillStyle(COLORS.neonGold); g.fillCircle(23, 8, 3);
        g.generateTexture('fairy', 32, 36);
        g.destroy();
    }

    static makeTim(scene) {
        const g = scene.make.graphics({ add: false });
        // Simple human NPC, slightly comedic proportions
        // Head
        g.fillStyle(0xffcc88); g.fillRect(8, 0, 16, 14);
        // Hair
        g.fillStyle(0x443322); g.fillRect(8, 0, 16, 5);
        // Eyes (skeptical expression)
        g.fillStyle(0xffffff); g.fillRect(11, 6, 4, 3); g.fillRect(18, 6, 4, 3);
        g.fillStyle(0x222222); g.fillRect(13, 6, 2, 3); g.fillRect(20, 6, 2, 3);
        // Eyebrows raised
        g.fillStyle(0x443322); g.fillRect(10, 4, 6, 1); g.fillRect(18, 4, 6, 1);
        // Suit
        g.fillStyle(0x333333); g.fillRect(6, 14, 20, 20);
        // Tie
        g.fillStyle(0xcc3333); g.fillRect(14, 14, 4, 12);
        // Legs
        g.fillStyle(0x222222); g.fillRect(10, 34, 5, 12); g.fillRect(17, 34, 5, 12);
        g.generateTexture('tim', 32, 48);
        g.destroy();
    }

    static makeParticle(scene) {
        const g = scene.make.graphics({ add: false });
        g.fillStyle(0xffffff); g.fillCircle(4, 4, 4);
        g.generateTexture('particle', 8, 8);
        g.destroy();
    }

    static makeStar(scene) {
        const g = scene.make.graphics({ add: false });
        g.fillStyle(COLORS.neonGold);
        // Simple 4-point star
        g.fillTriangle(6, 0, 4, 5, 8, 5);
        g.fillTriangle(6, 12, 4, 7, 8, 7);
        g.fillTriangle(0, 6, 5, 4, 5, 8);
        g.fillTriangle(12, 6, 7, 4, 7, 8);
        g.generateTexture('star', 12, 12);
        g.destroy();
    }

    static makeJoystickBase(scene) {
        const g = scene.make.graphics({ add: false });
        g.fillStyle(0xffffff, 0.15);
        g.fillCircle(50, 50, 50);
        g.lineStyle(2, COLORS.neonCyan, 0.3);
        g.strokeCircle(50, 50, 48);
        g.generateTexture('joystick_base', 100, 100);
        g.destroy();
    }

    static makeJoystickThumb(scene) {
        const g = scene.make.graphics({ add: false });
        g.fillStyle(0xffffff, 0.3);
        g.fillCircle(20, 20, 20);
        g.lineStyle(2, COLORS.neonCyan, 0.5);
        g.strokeCircle(20, 20, 18);
        g.generateTexture('joystick_thumb', 40, 40);
        g.destroy();
    }

    static makePortal(scene) {
        const g = scene.make.graphics({ add: false });
        g.fillStyle(COLORS.portalSwirl, 0.5);
        g.fillCircle(20, 20, 20);
        g.fillStyle(COLORS.bioPurple, 0.6);
        g.fillCircle(20, 20, 14);
        g.fillStyle(COLORS.neonCyan, 0.7);
        g.fillCircle(20, 20, 7);
        g.generateTexture('portal', 40, 40);
        g.destroy();
    }
}

// ============================================================================
// BOOT SCENE â€” Load assets, generate pixel art
// ============================================================================
class BootScene extends Phaser.Scene {
    constructor() { super('Boot'); }

    preload() {
        // Show loading bar
        const loadBg = this.add.rectangle(W/2, H/2, W * 0.62, 24, 0x111133);
        const bar = this.add.rectangle(W/2 - W * 0.3, H/2, 0, 20, COLORS.neonCyan).setOrigin(0, 0.5);
        this.add.text(W/2, H/2 - 30, 'Loading...', { fontSize: '16px', fill: '#aaaacc' }).setOrigin(0.5);
        this.load.on('progress', p => { bar.width = W * 0.6 * p; });

        // Track which external assets fail to load (we'll generate fallbacks)
        this.failedAssets = new Set();
        this.load.on('loaderror', (file) => {
            console.warn('Asset not found, will generate fallback:', file.key);
            this.failedAssets.add(file.key);
        });

        // ---- REAL SPRITE ASSETS (from GitHub repo) ----
        // Characters
        this.load.image('dante', 'Dante_32_Bit_Hero.png');
        this.load.image('coco', 'Coco_32_Bit_Hero.png');

        // Bosses
        this.load.image('boss1', 'Minion_Boss.png');
        this.load.image('boss2', 'Cowboy_Boss.png');
        this.load.image('boss3', 'Fire_Boss.png');
        this.load.image('boss4', 'Zombie_Boss.png');
        this.load.image('boss5', 'ChungLi_Boss.png');

        // Henchmen
        this.load.image('ghost', 'Ghost.png');
        this.load.image('horse', 'Horse.png');
        this.load.image('cattle', 'Cattle.png');
        this.load.image('piranha', 'Piranha.png');
        this.load.image('monkey', 'Flying_Monkey.png');
        this.load.image('unicorn', 'Unicorn.png');

        // NPCs
        this.load.image('wizard', 'Wizard.png');
        this.load.image('fairy', 'Fairy_Godmother.png');
        this.load.image('tim', 'Tim_Robinson.png');

        // Token
        this.load.image('token', 'Token.png');

        // Audio
        this.load.audio('timSound', 'Tim_audio.m4a');
    }

    create() {
        // Generate fallback pixel art ONLY for assets that failed to load
        // This way real assets take priority, but nothing crashes if missing
        const failedOrMissing = (key) => this.failedAssets.has(key) || !this.textures.exists(key);

        if (failedOrMissing('dante'))  PixelArt.makeCharacter(this, 'dante', COLORS.danteBlue, 0x2244aa, 0xffcc88);
        if (failedOrMissing('coco'))   PixelArt.makeCharacter(this, 'coco', COLORS.cocoPink, 0xcc4488, 0x8b5e3c);
        if (failedOrMissing('token'))  PixelArt.makeToken(this);
        if (failedOrMissing('ghost'))  PixelArt.makeGhost(this);
        if (failedOrMissing('horse'))  PixelArt.makeHorse(this);
        if (failedOrMissing('piranha')) PixelArt.makePiranha(this);
        if (failedOrMissing('monkey')) PixelArt.makeMonkey(this);
        if (failedOrMissing('unicorn')) PixelArt.makeUnicorn(this);
        if (failedOrMissing('boss1'))  PixelArt.makeBoss(this, 'boss1', 0xffcc00, 0xaa8800);
        if (failedOrMissing('boss2'))  PixelArt.makeBoss(this, 'boss2', 0x8B4513, 0x654321);
        if (failedOrMissing('boss3'))  PixelArt.makeBoss(this, 'boss3', 0xff4422, 0xcc2200);
        if (failedOrMissing('boss4'))  PixelArt.makeBoss(this, 'boss4', 0x556b2f, 0x3a4a1f);
        if (failedOrMissing('boss5'))  PixelArt.makeBoss(this, 'boss5', 0xff66aa, 0xcc4488);
        if (failedOrMissing('wizard')) PixelArt.makeWizard(this);
        if (failedOrMissing('fairy'))  PixelArt.makeFairy(this);
        if (failedOrMissing('tim'))    PixelArt.makeTim(this);

        // These are always generated (UI elements, not character sprites)
        PixelArt.makeHeart(this);
        PixelArt.makeCheckpoint(this);
        PixelArt.makeParticle(this);
        PixelArt.makeStar(this);
        PixelArt.makeJoystickBase(this);
        PixelArt.makeJoystickThumb(this);
        PixelArt.makePortal(this);

        this.scene.start('Title');
    }
}

// ============================================================================
// TITLE SCENE â€” Start screen, save slots, difficulty
// ============================================================================
class TitleScene extends Phaser.Scene {
    constructor() { super('Title'); }

    create() {
        const cx = W / 2, cy = H / 2;

        // Starfield background
        for (let i = 0; i < 80; i++) {
            const s = this.add.circle(
                Phaser.Math.Between(0, W), Phaser.Math.Between(0, H),
                Phaser.Math.Between(1, 3), COLORS.neonCyan, Phaser.Math.FloatBetween(0.1, 0.5)
            );
            this.tweens.add({ targets: s, alpha: 0.1, duration: Phaser.Math.Between(1000, 3000), yoyo: true, repeat: -1 });
        }

        // Title
        this.add.text(cx, 60, 'DANTE AND COCO', {
            fontSize: '42px', fontFamily: 'Helvetica, Arial, sans-serif',
            fontStyle: 'bold', fill: '#ffffff',
            stroke: '#00ffee', strokeThickness: 3
        }).setOrigin(0.5);

        this.add.text(cx, 105, 'SAVE THE DAY', {
            fontSize: '28px', fontFamily: 'Helvetica, Arial, sans-serif',
            fill: '#ffdd44', stroke: '#000', strokeThickness: 2
        }).setOrigin(0.5);

        // Characters preview (scaled for hi-res assets)
        initSize(this.add.image(cx - 60, 170, 'dante'), 72, 96);
        initSize(this.add.image(cx + 60, 170, 'coco'), 72, 96);

        // Save slots
        const slots = SaveManager.getSlots();
        const slotY = 260;

        for (let i = 0; i < 3; i++) {
            const sx = cx - 200 + (i * 200);
            const slot = slots[i];

            const box = this.add.rectangle(sx, slotY, 160, 70, COLORS.uiDark, 0.8)
                .setStrokeStyle(2, slot ? COLORS.neonCyan : 0x444466)
                .setInteractive({ useHandCursor: true });

            if (slot) {
                const lvl = LEVELS[slot.currentLevel] || LEVELS[0];
                this.add.text(sx, slotY - 18, `Slot ${i+1}`, { fontSize: '14px', fill: '#aaaacc' }).setOrigin(0.5);
                this.add.text(sx, slotY, lvl.name, { fontSize: '13px', fill: '#ffffff' }).setOrigin(0.5);
                this.add.text(sx, slotY + 18, `${slot.activeChar === 'dante' ? 'âš”' : 'âœ¦'} ${slot.difficulty}`, { fontSize: '12px', fill: '#88aacc' }).setOrigin(0.5);

                box.on('pointerdown', () => {
                    GameState.saveSlot = i;
                    GameState.fromSaveData(slot);
                    this.scene.start('Game');
                });
            } else {
                this.add.text(sx, slotY - 8, `Slot ${i+1}`, { fontSize: '14px', fill: '#666688' }).setOrigin(0.5);
                this.add.text(sx, slotY + 10, 'New Game', { fontSize: '13px', fill: '#8888aa' }).setOrigin(0.5);

                box.on('pointerdown', () => {
                    GameState.saveSlot = i;
                    this.showDifficultySelect(i);
                });
            }

            // Hover/press effects
            box.on('pointerover', () => box.setStrokeStyle(2, COLORS.neonGold));
            box.on('pointerout', () => box.setStrokeStyle(2, slot ? COLORS.neonCyan : 0x444466));
        }

        // Difficulty display area (hidden initially)
        this.diffGroup = this.add.group();
    }

    showDifficultySelect(slotIndex) {
        this.diffGroup.clear(true, true);

        const cx = W / 2, cy = 400;

        this.diffGroup.add(this.add.text(cx, cy - 40, 'Pick Difficulty:', {
            fontSize: '18px', fill: '#ffffff'
        }).setOrigin(0.5));

        const diffs = [
            { key: 'easy',   label: 'ðŸ°', name: 'Easy', x: cx - 140 },
            { key: 'normal', label: 'â­', name: 'Normal', x: cx },
            { key: 'hard',   label: 'ðŸ”¥', name: 'Hard', x: cx + 140 }
        ];

        diffs.forEach(d => {
            const btn = this.add.rectangle(d.x, cy + 10, 100, 50, COLORS.uiDark, 0.9)
                .setStrokeStyle(2, COLORS.neonCyan)
                .setInteractive({ useHandCursor: true });

            this.diffGroup.add(btn);
            this.diffGroup.add(this.add.text(d.x, cy, d.label, { fontSize: '22px' }).setOrigin(0.5));
            this.diffGroup.add(this.add.text(d.x, cy + 22, d.name, { fontSize: '12px', fill: '#aaaacc' }).setOrigin(0.5));

            btn.on('pointerdown', () => {
                GameState.reset();
                GameState.difficulty = d.key;
                GameState.saveSlot = slotIndex;
                SaveManager.save(slotIndex, GameState.toSaveData());
                this.scene.start('Game');
            });

            btn.on('pointerover', () => btn.setStrokeStyle(2, COLORS.neonGold));
            btn.on('pointerout', () => btn.setStrokeStyle(2, COLORS.neonCyan));
        });
    }
}

// ============================================================================
// GAME SCENE â€” Main platforming gameplay (Phase 1: Rainbow Meadow)
// ============================================================================
class GameScene extends Phaser.Scene {
    constructor() { super('Game'); }

    create() {
        this.levelData = LEVELS[GameState.currentLevel];
        const diff = GameState.getDifficulty();
        this.invincible = false;
        this.levelComplete = false;
        this.daylightPaused = false;
        this.tutorialStep = GameState.tutorialDone ? -1 : 0;
        this.tutorialPrompts = [];

        // ---- SKY / BACKGROUND ----
        this.createBackground();

        // ---- GROUND & PLATFORMS ----
        this.ground = this.physics.add.staticGroup();
        this.platforms = this.physics.add.staticGroup();
        this.createLevel();

        // ---- TOKENS ----
        this.tokenGroup = this.physics.add.group();
        this.createTokens(diff.tokenCount);

        // ---- CHECKPOINTS ----
        this.checkpoints = this.physics.add.staticGroup();
        this.createCheckpoints();

        // ---- HENCHMEN ----
        this.henchGroup = this.physics.add.group();
        this.createHenchmen(6, diff.henchSpeed);

        // ---- NPCs ----
        this.createNPCs();

        // ---- PLAYER ----
        this.createPlayer();

        // ---- CAMERA ----
        this.cameras.main.setBounds(0, 0, WORLD_WIDTH, H);
        this.cameras.main.startFollow(this.player, true, 0.08, 0.08);

        // ---- COLLISIONS ----
        this.physics.add.collider(this.player, this.ground);
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.henchGroup, this.ground);
        this.physics.add.collider(this.henchGroup, this.platforms);

        this.physics.add.overlap(this.player, this.tokenGroup, this.collectToken, null, this);
        this.physics.add.overlap(this.player, this.henchGroup, this.henchHit, null, this);
        this.physics.add.overlap(this.player, this.checkpoints, this.hitCheckpoint, null, this);

        // ---- INPUT (Roblox-style) ----
        this.createInput();

        // ---- HUD ----
        this.scene.launch('UI');

        // ---- DAYLIGHT TIMER ----
        this.daylightTimer = this.time.addEvent({
            delay: 1000,
            callback: this.tickDaylight,
            callbackScope: this,
            loop: true
        });

        // ---- BACKGROUND SAVE (iOS) ----
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) this.autoSave();
        });

        // ---- TUTORIAL (World 1 only) ----
        if (this.tutorialStep >= 0) this.showTutorialStep(0);

        // ---- BIOLUMINESCENT AMBIENT PARTICLES ----
        this.createAmbientParticles();
    }

    // ---- BACKGROUND (Pandora-style gradient + floating elements) ----
    createBackground() {
        const ld = this.levelData;
        // Sky gradient via rectangle layers
        for (let i = 0; i < 20; i++) {
            const t = i / 19;
            const color = Phaser.Display.Color.Interpolate.ColorWithColor(
                Phaser.Display.Color.ValueToColor(ld.skyTop),
                Phaser.Display.Color.ValueToColor(ld.skyBot),
                20, i
            );
            const c = Phaser.Display.Color.GetColor(color.r, color.g, color.b);
            this.add.rectangle(WORLD_WIDTH / 2, t * H, WORLD_WIDTH, H / 19 + 1, c).setDepth(-10);
        }

        // Distant bioluminescent plants (parallax feel via scroll factor)
        for (let i = 0; i < 30; i++) {
            const x = Phaser.Math.Between(0, WORLD_WIDTH);
            const baseY = H - Phaser.Math.Between(60, 200);
            const h = Phaser.Math.Between(30, 100);

            // Stem
            const stem = this.add.rectangle(x, baseY - h/2, 3, h, ld.bioAccent, 0.15).setDepth(-5);
            stem.setScrollFactor(0.5);

            // Glowing tip
            const tip = this.add.circle(x, baseY - h, Phaser.Math.Between(3, 8), ld.bioAccent, 0.2).setDepth(-5);
            tip.setScrollFactor(0.5);
            this.tweens.add({
                targets: tip, alpha: 0.05,
                duration: Phaser.Math.Between(1500, 3000),
                yoyo: true, repeat: -1
            });
        }
    }

    // ---- LEVEL GENERATION ----
    createLevel() {
        const ld = this.levelData;
        const groundY = H - 30;

        // Main ground segments with gaps
        const segments = [
            { x: 0, w: 600 },
            { x: 680, w: 400 },
            { x: 1160, w: 500 },
            { x: 1740, w: 600 },
            { x: 2420, w: 500 },
            { x: 3000, w: 600 },
            { x: 3680, w: 500 },
            { x: 4260, w: 540 }
        ];

        segments.forEach(seg => {
            const gnd = this.add.rectangle(seg.x + seg.w/2, groundY, seg.w, 40, ld.ground);
            this.physics.add.existing(gnd, true);
            this.ground.add(gnd);

            // Glow line on top
            const glow = this.add.rectangle(seg.x + seg.w/2, groundY - 18, seg.w, 3, ld.groundGlow, 0.4);
            this.tweens.add({ targets: glow, alpha: 0.15, duration: 2000, yoyo: true, repeat: -1 });
        });

        // Floating platforms
        const plats = [
            { x: 350, y: 350, w: 120 },
            { x: 630, y: 300, w: 100 },
            { x: 900, y: 340, w: 140 },
            { x: 1100, y: 260, w: 100 },
            { x: 1400, y: 320, w: 130 },
            { x: 1650, y: 280, w: 100 },
            { x: 1900, y: 350, w: 140 },
            { x: 2200, y: 260, w: 120 },
            { x: 2500, y: 310, w: 130 },
            { x: 2800, y: 270, w: 100 },
            { x: 3100, y: 340, w: 140 },
            { x: 3400, y: 290, w: 120 },
            { x: 3700, y: 250, w: 110 },
            { x: 4000, y: 330, w: 130 },
            { x: 4300, y: 280, w: 120 }
        ];

        plats.forEach(p => {
            const plat = this.add.rectangle(p.x, p.y, p.w, 16, ld.platform);
            this.physics.add.existing(plat, true);
            this.platforms.add(plat);

            // Platform glow
            const glow = this.add.rectangle(p.x, p.y - 6, p.w, 2, ld.platGlow, 0.3);
            this.tweens.add({ targets: glow, alpha: 0.1, duration: 1800, yoyo: true, repeat: -1 });

            // Some platforms bob gently
            if (Phaser.Math.Between(0, 2) === 0) {
                this.tweens.add({
                    targets: [plat, glow],
                    y: p.y - 10, duration: 2500,
                    yoyo: true, repeat: -1, ease: 'Sine.easeInOut'
                });
            }
        });
    }

    // ---- TOKENS ----
    createTokens(count) {
        const positions = [];
        // Spread tokens across the level
        for (let i = 0; i < count; i++) {
            const x = 200 + (i * (WORLD_WIDTH - 400) / count) + Phaser.Math.Between(-40, 40);
            const y = Phaser.Math.Between(200, H - 100);
            positions.push({ x, y });
        }

        positions.forEach(pos => {
            const token = this.tokenGroup.create(pos.x, pos.y, 'token');
            initSize(token, 24, 24);
            token.body.setAllowGravity(false);
            token.setDepth(5);
            // Gentle float
            this.tweens.add({
                targets: token, y: pos.y - 8,
                duration: 1200, yoyo: true, repeat: -1, ease: 'Sine.easeInOut'
            });
            // Glow
            const glow = this.add.circle(pos.x, pos.y, 14, COLORS.tokenGold, 0.15);
            this.tweens.add({ targets: glow, alpha: 0.05, scaleX: 1.3, scaleY: 1.3, duration: 1000, yoyo: true, repeat: -1 });
            token.setData('glow', glow);
        });
    }

    // ---- CHECKPOINTS ----
    createCheckpoints() {
        [1200, 2400, 3600].forEach(x => {
            const cp = this.checkpoints.create(x, H - 70, 'checkpoint');
            cp.setData('activated', false);
        });
    }

    // ---- HENCHMEN ----
    createHenchmen(count, speed) {
        const ld = this.levelData;
        for (let i = 0; i < count; i++) {
            const x = 600 + i * 650;
            // Pick henchman type: if array (Sky Ranch cattle+horse mix), pick randomly
            const henchType = Array.isArray(ld.henchKey)
                ? Phaser.Math.RND.pick(ld.henchKey)
                : ld.henchKey;

            const isFlyer = (henchType === 'piranha' || henchType === 'monkey');
            const y = isFlyer ? Phaser.Math.Between(150, 300) : H - 70;
            const h = this.henchGroup.create(x, y, henchType);
            initSize(h, 40, 40);
            h.setDepth(5);
            h.body.setAllowGravity(!isFlyer && henchType !== 'ghost');
            h.setData('baseY', y);
            h.setData('speed', speed);
            h.setData('alive', true);
            h.setData('henchType', henchType);

            // Movement patterns based on type
            if (henchType === 'ghost') {
                h.setVelocityX(-speed * 0.6);
                h.body.setAllowGravity(false);
            } else if (henchType === 'piranha') {
                h.setVelocityX(-speed * 0.8);
            } else if (henchType === 'cattle') {
                // Cattle: slower but wider patrol, charge when close
                h.setVelocityX(Phaser.Math.Between(0, 1) ? -speed * 0.7 : speed * 0.7);
                initSize(h, 48, 40); // slightly wider
            } else {
                h.setVelocityX(Phaser.Math.Between(0, 1) ? -speed : speed);
            }

            // Glow aura
            const glow = this.add.circle(x, y, 24, ld.henchColor, 0.1).setDepth(4);
            h.setData('glow', glow);
        }
    }

    // ---- NPCs ----
    createNPCs() {
        // Wizard at ~40% of level
        this.wizard = this.physics.add.sprite(WORLD_WIDTH * 0.4, H - 80, 'wizard');
        initSize(this.wizard, 40, 56);
        this.wizard.body.setAllowGravity(false);
        this.wizard.setDepth(6);
        this.wizardActivated = false;

        // Wizard glow
        const wizGlow = this.add.circle(this.wizard.x, this.wizard.y, 30, COLORS.bioPurple, 0.15);
        this.tweens.add({ targets: wizGlow, alpha: 0.05, scaleX: 1.4, scaleY: 1.4, duration: 2000, yoyo: true, repeat: -1 });

        this.physics.add.overlap(this.player, this.wizard, this.meetWizard, null, this);

        // Fairy Godmother at ~25%
        this.fairy = this.physics.add.sprite(WORLD_WIDTH * 0.25, H - 80, 'fairy');
        initSize(this.fairy, 40, 56);
        this.fairy.body.setAllowGravity(false);
        this.fairy.setDepth(6);
        this.fairyUsed = false;

        const fairyGlow = this.add.circle(this.fairy.x, this.fairy.y, 25, COLORS.neonGold, 0.15);
        this.tweens.add({ targets: fairyGlow, alpha: 0.05, scaleX: 1.3, scaleY: 1.3, duration: 1500, yoyo: true, repeat: -1 });

        this.physics.add.overlap(this.player, this.fairy, this.meetFairy, null, this);

        // Tim Robinson at ~85% (before boss portal)
        this.tim = this.physics.add.sprite(WORLD_WIDTH * 0.85, H - 80, 'tim');
        initSize(this.tim, 40, 56);
        this.tim.body.setAllowGravity(false);
        this.tim.setDepth(6);
        this.timActivated = false;
        this.timBubble = this.add.text(this.tim.x - 40, this.tim.y - 50, '', {
            fontSize: '14px', fill: '#ffffff',
            backgroundColor: '#000000aa', padding: { x: 8, y: 4 }
        }).setDepth(7).setVisible(false);

        // Boss portal (locked initially)
        this.bossPortal = this.add.image(WORLD_WIDTH * 0.9, H - 70, 'portal').setScale(2).setDepth(5).setAlpha(0.3);
        this.bossPortalActive = false;
    }

    // ---- PLAYER ----
    createPlayer() {
        const startX = GameState.checkpointX || 100;
        this.player = this.physics.add.sprite(startX, H - 100, GameState.activeChar);
        initSize(this.player, 36, 48);
        this.player.setDepth(10);
        this.player.setCollideWorldBounds(false);
        this.player.body.setSize(36, 48);
        this.player.body.setOffset(0, 0);

        // Player glow outline
        this.playerGlow = this.add.circle(startX, H - 100, 24,
            GameState.activeChar === 'dante' ? COLORS.danteBlue : COLORS.cocoPink, 0.12
        ).setDepth(9);

        // Attack cooldown
        this.attackCooldown = 0;
        this.dashActive = false;
        this.shieldActive = false;
        this.hoverActive = false;

        // Projectile group for Coco
        this.projectiles = this.physics.add.group();
        this.physics.add.overlap(this.projectiles, this.henchGroup, this.projectileHitHench, null, this);
    }

    // ---- INPUT SYSTEM (Roblox/Minecraft style) ----
    createInput() {
        this.inputState = { moveX: 0, jump: false, jumpHeld: false, action: false, actionHeld: false };
        this.joystick = { active: false, startX: 0, startY: 0, baseSprite: null, thumbSprite: null };

        // Left third = joystick zone
        this.joystickZone = this.add.rectangle(W * 0.2, H * 0.5, W * 0.4, H, 0x000000, 0)
            .setScrollFactor(0).setInteractive().setDepth(100);

        this.joystickZone.on('pointerdown', (ptr) => {
            this.joystick.active = true;
            this.joystick.startX = ptr.x;
            this.joystick.startY = ptr.y;
            this.joystick.baseSprite = this.add.image(ptr.x, ptr.y, 'joystick_base').setScrollFactor(0).setDepth(101);
            this.joystick.thumbSprite = this.add.image(ptr.x, ptr.y, 'joystick_thumb').setScrollFactor(0).setDepth(102);
        });

        this.joystickZone.on('pointermove', (ptr) => {
            if (!this.joystick.active) return;
            const dx = ptr.x - this.joystick.startX;
            const maxDist = 40;
            const clampedX = Phaser.Math.Clamp(dx, -maxDist, maxDist);
            if (this.joystick.thumbSprite) {
                this.joystick.thumbSprite.x = this.joystick.startX + clampedX;
            }
            // Dead zone
            if (Math.abs(clampedX) > 8) {
                this.inputState.moveX = clampedX / maxDist;
            } else {
                this.inputState.moveX = 0;
            }
        });

        const endJoystick = () => {
            this.joystick.active = false;
            this.inputState.moveX = 0;
            if (this.joystick.baseSprite) { this.joystick.baseSprite.destroy(); this.joystick.baseSprite = null; }
            if (this.joystick.thumbSprite) { this.joystick.thumbSprite.destroy(); this.joystick.thumbSprite = null; }
        };
        this.joystickZone.on('pointerup', endJoystick);
        this.joystickZone.on('pointerout', endJoystick);

        // Jump button (bottom-right, Roblox position)
        this.jumpBtn = this.createActionButton(W - 80, H - 80, 'â–²', COLORS.neonCyan, 36);
        this.jumpBtn.on('pointerdown', () => { this.inputState.jump = true; this.inputState.jumpHeld = true; });
        this.jumpBtn.on('pointerup', () => { this.inputState.jump = false; this.inputState.jumpHeld = false; });
        this.jumpBtn.on('pointerout', () => { this.inputState.jump = false; this.inputState.jumpHeld = false; });

        // Action button (above jump)
        this.actionBtn = this.createActionButton(W - 80, H - 170, 'âš¡', COLORS.neonGold, 36);
        this.actionBtn.on('pointerdown', () => { this.inputState.action = true; this.inputState.actionHeld = true; });
        this.actionBtn.on('pointerup', () => { this.inputState.action = false; this.inputState.actionHeld = false; });
        this.actionBtn.on('pointerout', () => { this.inputState.action = false; this.inputState.actionHeld = false; });

        // Character switch (top-right, small)
        const switchChar = GameState.activeChar === 'dante' ? 'coco' : 'dante';
        this.switchBtn = this.add.image(W - 40, 40, switchChar);
        initSize(this.switchBtn, 30, 40);
        this.switchBtn.setScrollFactor(0).setDepth(100).setInteractive().setAlpha(0.7);
        const switchBorder = this.add.circle(W - 40, 40, 20, 0x000000, 0)
            .setScrollFactor(0).setDepth(99).setStrokeStyle(2, COLORS.neonCyan, 0.5);

        this.switchBtn.on('pointerdown', () => {
            GameState.activeChar = GameState.activeChar === 'dante' ? 'coco' : 'dante';
            this.player.setTexture(GameState.activeChar);
            this.playerGlow.fillColor = GameState.activeChar === 'dante' ? COLORS.danteBlue : COLORS.cocoPink;
            this.switchBtn.setTexture(GameState.activeChar === 'dante' ? 'coco' : 'dante');
            this.hoverActive = false;
            this.dashActive = false;
            this.shieldActive = false;
        });

        // Pause button (top-left)
        const pauseBtn = this.add.text(20, 10, 'âš™', { fontSize: '28px' })
            .setScrollFactor(0).setDepth(100).setInteractive();
        pauseBtn.on('pointerdown', () => {
            this.autoSave();
            this.scene.launch('Pause');
            this.scene.pause();
        });

        // Keyboard fallback (for testing)
        this.cursors = this.input.keyboard.createCursorKeys();
        this.keys = this.input.keyboard.addKeys('A,D,W,SPACE,F');
    }

    createActionButton(x, y, label, color, radius) {
        const bg = this.add.circle(x, y, radius, 0x000000, 0.3)
            .setScrollFactor(0).setDepth(100).setStrokeStyle(3, color, 0.6)
            .setInteractive();
        this.add.text(x, y, label, { fontSize: '20px', fill: '#ffffff' })
            .setOrigin(0.5).setScrollFactor(0).setDepth(101);

        bg.on('pointerdown', () => { bg.setScale(0.9); bg.setAlpha(0.5); });
        bg.on('pointerup', () => { bg.setScale(1); bg.setAlpha(0.3); });
        bg.on('pointerout', () => { bg.setScale(1); bg.setAlpha(0.3); });
        return bg;
    }

    // ---- AMBIENT PARTICLES (Pandora floating spores) ----
    createAmbientParticles() {
        if (!this.textures.exists('particle')) return;
        this.ambientEmitter = this.add.particles(0, 0, 'particle', {
            x: { min: 0, max: WORLD_WIDTH },
            y: { min: 0, max: H },
            lifespan: 6000,
            speed: { min: 5, max: 20 },
            scale: { start: 0.3, end: 0 },
            alpha: { start: 0.3, end: 0 },
            tint: [COLORS.neonCyan, COLORS.bioGreen, COLORS.bioPurple],
            frequency: 200,
            blendMode: 'ADD'
        }).setDepth(2);
    }

    // ---- UPDATE LOOP ----
    update(time, delta) {
        if (this.levelComplete) return;

        // Keyboard input (testing fallback)
        if (this.cursors.left.isDown || this.keys.A.isDown) this.inputState.moveX = -1;
        else if (this.cursors.right.isDown || this.keys.D.isDown) this.inputState.moveX = 1;
        else if (!this.joystick.active) this.inputState.moveX = 0;

        if (this.cursors.up.isDown || this.keys.W.isDown || this.keys.SPACE.isDown) {
            this.inputState.jump = true;
            this.inputState.jumpHeld = true;
        }
        if (Phaser.Input.Keyboard.JustDown(this.keys.F)) this.inputState.action = true;

        // ---- MOVEMENT ----
        const speed = this.dashActive ? 450 : 280;
        this.player.setVelocityX(this.inputState.moveX * speed);

        if (this.inputState.moveX < 0) this.player.setFlipX(true);
        else if (this.inputState.moveX > 0) this.player.setFlipX(false);

        // ---- JUMP (with coyote time) ----
        const onGround = this.player.body.blocked.down;
        if (onGround) this.lastGrounded = time;

        const coyoteWindow = 150;
        const canJump = onGround || (time - (this.lastGrounded || 0) < coyoteWindow);

        if (this.inputState.jump && canJump && !this.hoverActive) {
            this.player.setVelocityY(-520);
            this.lastGrounded = 0;
            this.inputState.jump = false;
        }

        // Coco hover (hold jump in air)
        if (GameState.activeChar === 'coco' && this.inputState.jumpHeld && !onGround && this.player.body.velocity.y > 0) {
            this.player.setVelocityY(Math.max(this.player.body.velocity.y - 30, -50));
            this.hoverActive = true;
        } else {
            this.hoverActive = false;
        }

        // ---- ATTACK / SPECIAL ----
        if (this.attackCooldown > 0) this.attackCooldown -= delta;

        if (this.inputState.action && this.attackCooldown <= 0) {
            if (GameState.activeChar === 'dante') {
                this.danteAttack();
            } else {
                this.cocoAttack();
            }
            this.attackCooldown = 300;
            this.inputState.action = false;
        }

        // Dante dash (hold action)
        if (GameState.activeChar === 'dante' && this.inputState.actionHeld && !this.dashActive) {
            // Dash activates after holding for 400ms
        }

        // Coco shield (hold action)
        if (GameState.activeChar === 'coco' && this.inputState.actionHeld) {
            this.shieldActive = true;
            this.invincible = true;
        } else if (GameState.activeChar === 'coco') {
            if (this.shieldActive) {
                this.shieldActive = false;
                this.invincible = false;
            }
        }

        // ---- UPDATE PLAYER GLOW POSITION ----
        this.playerGlow.x = this.player.x;
        this.playerGlow.y = this.player.y;

        // Shield visual
        if (this.shieldActive) {
            this.playerGlow.setRadius(30);
            this.playerGlow.setAlpha(0.25);
            this.playerGlow.fillColor = COLORS.neonCyan;
        } else {
            this.playerGlow.setRadius(24);
            this.playerGlow.setAlpha(0.12);
            this.playerGlow.fillColor = GameState.activeChar === 'dante' ? COLORS.danteBlue : COLORS.cocoPink;
        }

        // ---- SPRITE ANIMATIONS (code-based, single-frame sprites) ----
        this.animatePlayer(time, delta);
        this.animateHenchmenSprites(time);
        this.animateNPCs(time);

        // ---- HENCHMEN AI ----
        this.updateHenchmen();

        // ---- TIM ROBINSON PROXIMITY ----
        this.updateTim();

        // ---- FALL DETECTION ----
        if (this.player.y > H + 50) {
            this.playerDie();
        }

        // ---- TOKEN MAGNET ----
        this.tokenGroup.getChildren().forEach(token => {
            if (!token.active) return;
            const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, token.x, token.y);
            if (dist < 80) {
                const angle = Phaser.Math.Angle.Between(token.x, token.y, this.player.x, this.player.y);
                token.x += Math.cos(angle) * 3;
                token.y += Math.sin(angle) * 3;
                const glow = token.getData('glow');
                if (glow) { glow.x = token.x; glow.y = token.y; }
            }
        });

        // ---- UPDATE HENCHMEN GLOWS ----
        this.henchGroup.getChildren().forEach(h => {
            const glow = h.getData('glow');
            if (glow) { glow.x = h.x; glow.y = h.y; }
        });

        // ---- EMIT UI EVENT ----
        this.events.emit('updateHUD');
    }

    // ================================================================
    // SPRITE ANIMATION SYSTEM (code-based, no spritesheets needed)
    // Brings single-frame sprites to life with squash/stretch/bob/tilt
    // ================================================================

    animatePlayer(time, delta) {
        const p = this.player;
        const bx = p._bsx || p.scaleX, by = p._bsy || p.scaleY; // base scales
        const vx = p.body.velocity.x;
        const vy = p.body.velocity.y;
        const onGround = p.body.blocked.down;
        const isMoving = Math.abs(vx) > 10;
        const isAttacking = this.attackCooldown > 200;

        // ---- IDLE BREATHING ----
        if (!isMoving && onGround && !isAttacking) {
            const breathe = 1 + Math.sin(time / 400) * 0.03;
            p.setScale(bx * breathe, by / breathe);
        }

        // ---- RUN CYCLE (bob + tilt) ----
        if (isMoving && onGround) {
            const bob = Math.sin(time / 80) * 2;
            p.y += bob * (delta / 16);
            const lean = vx > 0 ? 0.07 : -0.07;
            p.setRotation(lean);
            p.setScale(bx * 1.03, by * 0.97);
        } else if (onGround && !isAttacking) {
            p.setRotation(0);
        }

        // ---- JUMP & FALL ----
        if (!onGround) {
            if (vy < -100) {
                const stretch = Math.min(1.15, 1 + Math.abs(vy) / 3000);
                p.setScale(bx / stretch, by * stretch);
                p.setRotation(0);
            } else if (vy > 50) {
                const spread = Math.min(1.12, 1 + vy / 3000);
                p.setScale(bx * spread, by / spread);
            }

            if (this.hoverActive) {
                p.setRotation(Math.sin(time / 200) * 0.1);
                p.setScale(bx, by * (1 + Math.sin(time / 300) * 0.03));
            }
        }

        // ---- LAND SQUASH (one-shot) ----
        if (onGround && this._wasInAir) {
            this.tweens.add({
                targets: p,
                scaleX: bx * 1.13, scaleY: by * 0.87,
                duration: 60, yoyo: true,
                ease: 'Quad.easeOut',
                onComplete: () => { p.setScale(bx, by); }
            });
        }
        this._wasInAir = !onGround;

        // ---- ATTACK PUNCH (scale burst) ----
        if (isAttacking) {
            const dir = p.flipX ? -1 : 1;
            p.setScale(bx * 1.07, by * 0.93);
            p.setRotation(dir * -0.15);
        }

        // ---- DASH (Dante) ----
        if (this.dashActive) {
            p.setScale(bx * 1.13, by * 0.87);
            p.setRotation(p.flipX ? -0.2 : 0.2);
        }

        // ---- SHIELD (Coco) ----
        if (this.shieldActive) {
            const pulse = 1 + Math.sin(time / 150) * 0.05;
            p.setScale(bx * pulse, by * pulse);
            p.setRotation(0);
        }

        // ---- INVINCIBILITY FLASH ----
        if (this.invincible) {
            p.setAlpha(Math.sin(time / 60) > 0 ? 0.8 : 0.3);
        }
    }

    animateHenchmenSprites(time) {
        this.henchGroup.getChildren().forEach(h => {
            if (!h.active || !h.getData('alive')) return;
            const type = h.getData('henchType') || 'ghost';
            const bx = h._bsx || h.scaleX, by = h._bsy || h.scaleY;

            // Ghost: ethereal wobble + pulsing transparency
            if (type === 'ghost') {
                const f = 1 + Math.sin(time / 300 + h.x) * 0.08;
                h.setScale(bx * f, by * f);
                h.setAlpha(0.6 + Math.sin(time / 500 + h.x) * 0.25);
                h.setRotation(Math.sin(time / 400 + h.x) * 0.15);
            }

            // Horse: gallop bob
            if (type === 'horse') {
                const gallop = Math.abs(Math.sin(time / 100 + h.x)) * 3;
                h.y -= gallop * 0.1;
                h.setRotation(Math.sin(time / 100 + h.x) * 0.05);
                if (h.body.velocity.x < 0) h.setFlipX(true);
                else if (h.body.velocity.x > 0) h.setFlipX(false);
            }

            // Cattle: heavy stomping bob, wider
            if (type === 'cattle') {
                const stomp = Math.abs(Math.sin(time / 150 + h.x)) * 2;
                h.y -= stomp * 0.08;
                h.setScale(bx * (1 + Math.sin(time / 200) * 0.04), by * (1 - Math.sin(time / 200) * 0.03));
                if (h.body.velocity.x < 0) h.setFlipX(true);
                else if (h.body.velocity.x > 0) h.setFlipX(false);
            }

            // Piranha: flapping fins + mouth snapping
            if (type === 'piranha') {
                h.setScale(bx * (1 + Math.sin(time / 200 + h.x) * 0.1), by * (1 - Math.sin(time / 200 + h.x) * 0.06));
                h.setRotation(Math.sin(time / 300 + h.x) * 0.2);
                if (h.body.velocity.x < 0) h.setFlipX(true);
                else if (h.body.velocity.x > 0) h.setFlipX(false);
            }

            // Monkey: swinging / bouncy
            if (type === 'monkey') {
                h.setRotation(Math.sin(time / 250 + h.x) * 0.3);
                const f = 1 + Math.sin(time / 180) * 0.06;
                h.setScale(bx * f, by * f);
            }

            // Unicorn: prancing + sparkle scale
            if (type === 'unicorn') {
                const prance = Math.sin(time / 120 + h.x) * 4;
                h.y -= prance * 0.05;
                const f = 1 + Math.sin(time / 300) * 0.05;
                h.setScale(bx * f, by * f);
                h.setRotation(Math.sin(time / 200 + h.x) * 0.08);
                if (h.body.velocity.x < 0) h.setFlipX(true);
                else if (h.body.velocity.x > 0) h.setFlipX(false);
            }
        });
    }

    animateNPCs(time) {
        // Wizard: gentle hover + mystical sway
        if (this.wizard && this.wizard.active && !this.wizardActivated) {
            const w = this.wizard, wbx = w._bsx || w.scaleX, wby = w._bsy || w.scaleY;
            w.y += Math.sin(time / 600) * 0.3;
            w.setRotation(Math.sin(time / 800) * 0.05);
            const f = 1 + Math.sin(time / 500) * 0.03;
            w.setScale(wbx * f, wby * f);
        }

        // Fairy: fluttering up/down + wing-beat scale
        if (this.fairy && this.fairy.visible && !this.fairyUsed) {
            const f = this.fairy, fbx = f._bsx || f.scaleX, fby = f._bsy || f.scaleY;
            f.y += Math.sin(time / 300) * 0.5;
            f.setScale(fbx * (1 + Math.sin(time / 150) * 0.08), fby * (1 - Math.sin(time / 150) * 0.04));
            f.setRotation(Math.sin(time / 400) * 0.1);
        }

        // Tim: subtle impatient weight shift
        if (this.tim && this.tim.active && !this.timActivated) {
            const t = this.tim, tbx = t._bsx || t.scaleX, tby = t._bsy || t.scaleY;
            t.setScale(tbx * (1 + Math.sin(time / 700) * 0.02), tby * (1 - Math.sin(time / 700) * 0.02));
            t.setRotation(Math.sin(time / 1200) * 0.04);
        }
    }

    // ---- DANTE ATTACK: Lightsaber sweep ----
    danteAttack() {
        const dir = this.player.flipX ? -1 : 1;
        const hitX = this.player.x + dir * 45;
        const hitY = this.player.y;

        // Visual: cyan arc
        const arc = this.add.circle(hitX, hitY, 35, COLORS.neonCyan, 0.4).setDepth(11);
        this.tweens.add({ targets: arc, alpha: 0, scaleX: 1.5, scaleY: 1.5, duration: 200, onComplete: () => arc.destroy() });

        // Check henchmen hit
        this.henchGroup.getChildren().forEach(h => {
            if (!h.getData('alive')) return;
            if (Phaser.Math.Distance.Between(hitX, hitY, h.x, h.y) < 60) {
                this.defeatHenchman(h);
            }
        });

        // Check boss hit (if boss exists)
        if (this.boss && Phaser.Math.Distance.Between(hitX, hitY, this.boss.x, this.boss.y) < 70) {
            this.hitBoss();
        }
    }

    // ---- COCO ATTACK: Star projectile with auto-aim ----
    cocoAttack() {
        const dir = this.player.flipX ? -1 : 1;
        const proj = this.projectiles.create(this.player.x + dir * 20, this.player.y, 'star');
        proj.body.setAllowGravity(false);
        proj.setDepth(11);

        // Slight auto-aim toward nearest enemy
        let targetX = this.player.x + dir * 500;
        let targetY = this.player.y;
        let nearestDist = Infinity;

        this.henchGroup.getChildren().forEach(h => {
            if (!h.getData('alive')) return;
            const d = Phaser.Math.Distance.Between(this.player.x, this.player.y, h.x, h.y);
            if (d < nearestDist && d < 400) {
                nearestDist = d;
                targetX = h.x;
                targetY = h.y;
            }
        });

        const angle = Phaser.Math.Angle.Between(proj.x, proj.y, targetX, targetY);
        proj.setVelocity(Math.cos(angle) * 400, Math.sin(angle) * 400);

        // Destroy after 1.5s
        this.time.delayedCall(1500, () => { if (proj.active) proj.destroy(); });
    }

    projectileHitHench(proj, hench) {
        if (!hench.getData('alive')) return;
        proj.destroy();
        this.defeatHenchman(hench);
    }

    // ---- DEFEAT HENCHMAN (sparkle poof!) ----
    defeatHenchman(h) {
        h.setData('alive', false);

        // Sparkle explosion
        for (let i = 0; i < 12; i++) {
            const spark = this.add.circle(h.x, h.y, Phaser.Math.Between(2, 5),
                Phaser.Math.RND.pick([COLORS.neonCyan, COLORS.neonGold, COLORS.neonMagenta, COLORS.white]),
                0.8
            ).setDepth(12);
            this.tweens.add({
                targets: spark,
                x: h.x + Phaser.Math.Between(-50, 50),
                y: h.y + Phaser.Math.Between(-50, 50),
                alpha: 0, scale: 0,
                duration: 500,
                onComplete: () => spark.destroy()
            });
        }

        const glow = h.getData('glow');
        if (glow) glow.destroy();
        h.destroy();

        // Respawn after delay
        this.time.delayedCall(5000, () => {
            if (this.scene.isActive()) {
                const diff = GameState.getDifficulty();
                const x = this.player.x + Phaser.Math.Between(400, 800) * (Phaser.Math.Between(0,1) ? 1 : -1);
                const ld = this.levelData;
                // Pick type (handles array for Sky Ranch mix)
                const henchType = Array.isArray(ld.henchKey) ? Phaser.Math.RND.pick(ld.henchKey) : ld.henchKey;
                const isFlyer = (henchType === 'piranha' || henchType === 'monkey');
                const y = isFlyer ? Phaser.Math.Between(150, 300) : H - 70;
                const newH = this.henchGroup.create(Phaser.Math.Clamp(x, 100, WORLD_WIDTH - 100), y, henchType);
                newH.setDisplaySize(henchType === 'cattle' ? 48 : 40, 40).setDepth(5);
                newH.body.setAllowGravity(!isFlyer && henchType !== 'ghost');
                newH.setData('speed', diff.henchSpeed);
                newH.setData('alive', true);
                newH.setData('baseY', y);
                newH.setData('henchType', henchType);
                newH.setVelocityX(Phaser.Math.Between(0,1) ? -diff.henchSpeed : diff.henchSpeed);
                const gl = this.add.circle(newH.x, newH.y, 24, ld.henchColor, 0.1).setDepth(4);
                newH.setData('glow', gl);
            }
        });
    }

    // ---- HENCHMEN AI UPDATE ----
    updateHenchmen() {
        this.henchGroup.getChildren().forEach(h => {
            if (!h.getData('alive') || !h.active) return;
            const type = h.getData('henchType') || 'ghost';

            // Bounce off world edges
            if (h.x < 20) h.setVelocityX(Math.abs(h.body.velocity.x));
            if (h.x > WORLD_WIDTH - 20) h.setVelocityX(-Math.abs(h.body.velocity.x));

            // Ghost: float toward player
            if (type === 'ghost') {
                const angle = Phaser.Math.Angle.Between(h.x, h.y, this.player.x, this.player.y);
                const spd = h.getData('speed') * 0.5;
                h.setVelocity(Math.cos(angle) * spd, Math.sin(angle) * spd);
            }

            // Piranha: sine wave
            if (type === 'piranha') {
                const baseY = h.getData('baseY');
                h.y = baseY + Math.sin(this.time.now / 500 + h.x) * 40;
            }

            // Cattle: charge toward player when close
            if (type === 'cattle') {
                const dist = Phaser.Math.Distance.Between(h.x, h.y, this.player.x, this.player.y);
                if (dist < 250) {
                    const dir = this.player.x < h.x ? -1 : 1;
                    h.setVelocityX(dir * h.getData('speed') * 1.4);
                    h.setFlipX(dir < 0);
                }
            }

            // Monkey: dive-bomb when above player
            if (type === 'monkey') {
                const dx = Math.abs(h.x - this.player.x);
                if (dx < 100 && h.y < this.player.y) {
                    h.setVelocityY(h.getData('speed') * 1.2);
                } else {
                    const baseY = h.getData('baseY');
                    if (h.y > baseY + 10) h.setVelocityY(-h.getData('speed') * 0.5);
                    else if (h.y < baseY - 10) h.setVelocityY(h.getData('speed') * 0.3);
                }
            }

            // Unicorn: bounce off walls with rainbow energy
            if (type === 'unicorn') {
                if (h.body && h.body.blocked.left) h.setVelocityX(h.getData('speed'));
                if (h.body && h.body.blocked.right) h.setVelocityX(-h.getData('speed'));
            }
        });
    }

    // ---- TOKEN COLLECTION ----
    collectToken(player, token) {
        GameState.tokens++;
        const diff = GameState.getDifficulty();
        GameState.daylight = Math.min(100, GameState.daylight + diff.tokenTimeBonus);

        // Sparkle effect
        for (let i = 0; i < 6; i++) {
            const s = this.add.circle(token.x, token.y, 3, COLORS.neonGold, 0.8).setDepth(12);
            this.tweens.add({
                targets: s, x: s.x + Phaser.Math.Between(-30, 30), y: s.y + Phaser.Math.Between(-40, -10),
                alpha: 0, duration: 400, onComplete: () => s.destroy()
            });
        }

        const glow = token.getData('glow');
        if (glow) glow.destroy();
        token.destroy();

        // Check if enough tokens for boss portal
        if (GameState.tokens >= diff.tokensNeeded && !this.bossPortalActive) {
            this.bossPortalActive = true;
            this.bossPortal.setAlpha(1);
            this.tweens.add({ targets: this.bossPortal, scaleX: 2.3, scaleY: 2.3, duration: 500, yoyo: true, repeat: -1 });
        }
    }

    // ---- HENCHMAN COLLISION (steal token) ----
    henchHit(player, hench) {
        if (this.invincible || !hench.getData('alive')) return;
        if (GameState.tokens > 0) GameState.tokens--;

        this.invincible = true;
        this.player.setAlpha(0.5);

        // Flash red
        this.cameras.main.flash(200, 255, 50, 50);

        this.time.delayedCall(1500, () => {
            this.invincible = false;
            if (this.player) this.player.setAlpha(1);
        });
    }

    // ---- CHECKPOINT ----
    hitCheckpoint(player, checkpoint) {
        if (checkpoint.getData('activated')) return;
        checkpoint.setData('activated', true);
        checkpoint.setTint(COLORS.neonCyan);
        GameState.checkpointX = checkpoint.x;
        this.autoSave();

        // Activation sparkle
        for (let i = 0; i < 8; i++) {
            const s = this.add.circle(checkpoint.x, checkpoint.y - 10, 3, COLORS.neonCyan, 0.7).setDepth(12);
            this.tweens.add({
                targets: s, y: s.y - 40 - Phaser.Math.Between(0, 30), alpha: 0,
                duration: 600, onComplete: () => s.destroy()
            });
        }
    }

    // ---- NPC: WIZARD ----
    meetWizard(player, wizard) {
        if (this.wizardActivated) return;
        this.wizardActivated = true;

        // Flash + transition to secret room
        this.cameras.main.flash(800, 0, 100, 255);
        this.time.delayedCall(800, () => {
            this.daylightPaused = true;
            this.scene.launch('SecretRoom');
            this.scene.pause();
        });
    }

    // ---- NPC: FAIRY ----
    meetFairy(player, fairy) {
        if (this.fairyUsed) return;
        this.fairyUsed = true;

        // Restore hearts
        if (GameState.hearts < GameState.maxHearts) {
            GameState.hearts = GameState.maxHearts;
        } else if (GameState.maxHearts < 4) {
            GameState.maxHearts++;
            GameState.hearts = GameState.maxHearts;
        }

        // Sparkle burst
        for (let i = 0; i < 15; i++) {
            const s = this.add.circle(fairy.x, fairy.y, Phaser.Math.Between(2, 5),
                Phaser.Math.RND.pick([COLORS.neonGold, COLORS.neonCyan, COLORS.white]), 0.8
            ).setDepth(12);
            this.tweens.add({
                targets: s,
                x: s.x + Phaser.Math.Between(-60, 60), y: s.y + Phaser.Math.Between(-60, 60),
                alpha: 0, scale: 0, duration: 800, onComplete: () => s.destroy()
            });
        }

        fairy.setVisible(false);
    }

    // ---- NPC: TIM ROBINSON ----
    updateTim() {
        const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, this.tim.x, this.tim.y);
        const diff = GameState.getDifficulty();

        if (dist < 120) {
            if (GameState.tokens >= diff.tokensNeeded) {
                this.timBubble.setText('?!').setVisible(true);
                this.timBubble.setPosition(this.tim.x - 15, this.tim.y - 55);

                if (!this.timActivated) {
                    // Player needs to tap action to trigger Tim
                    if (this.inputState.action) {
                        this.timActivated = true;
                        // Play audio (iOS safe - triggered by user tap)
                        try { this.sound.play('timSound'); } catch(e) {}
                        this.timBubble.setText('YOU SURE\nABOUT THAT?').setVisible(true);

                        // Open boss portal
                        this.time.delayedCall(2000, () => {
                            this.tim.setAlpha(0.5);
                            this.timBubble.setVisible(false);
                            // Transition to boss
                            this.scene.start('Boss', { level: GameState.currentLevel });
                        });
                    }
                }
            } else {
                const needed = diff.tokensNeeded - GameState.tokens;
                this.timBubble.setText(`Need ${needed} more!`).setVisible(true);
                this.timBubble.setPosition(this.tim.x - 40, this.tim.y - 55);
            }
        } else {
            this.timBubble.setVisible(false);
        }
    }

    // ---- DAYLIGHT TIMER ----
    tickDaylight() {
        if (this.daylightPaused || this.levelComplete) return;
        const diff = GameState.getDifficulty();
        const decrement = 100 / diff.dayTime; // percentage per second
        GameState.daylight = Math.max(0, GameState.daylight - decrement);

        if (GameState.daylight <= 0) {
            this.nightFallen();
        }
    }

    nightFallen() {
        this.levelComplete = true;
        // Game over screen
        const overlay = this.add.rectangle(W/2, H/2, W, H, 0x000011, 0.9).setScrollFactor(0).setDepth(200);
        const moon = this.add.circle(W/2, H/2 - 60, 30, 0xccccdd).setScrollFactor(0).setDepth(201);
        this.add.text(W/2, H/2 + 20, 'NIGHT HAS FALLEN', {
            fontSize: '32px', fill: '#ffffff', fontStyle: 'bold', stroke: '#4444aa', strokeThickness: 3
        }).setOrigin(0.5).setScrollFactor(0).setDepth(201);

        const tryAgain = this.add.text(W/2, H/2 + 70, '[ Try Again ]', {
            fontSize: '20px', fill: '#ffdd44'
        }).setOrigin(0.5).setScrollFactor(0).setDepth(201).setInteractive();

        tryAgain.on('pointerdown', () => {
            GameState.daylight = 50;
            GameState.hearts = 3;
            this.scene.stop('UI');
            this.scene.restart();
        });
    }

    // ---- PLAYER DEATH ----
    playerDie() {
        GameState.hearts--;
        GameState.deathsInSection++;

        if (GameState.hearts <= 0) {
            GameState.hearts = 3;
        }

        // Respawn at checkpoint
        this.player.setPosition(GameState.checkpointX, H - 100);
        this.player.setVelocity(0, 0);

        // Brief invincibility
        this.invincible = true;
        this.player.setAlpha(0.5);
        this.time.delayedCall(2000, () => {
            this.invincible = false;
            if (this.player) this.player.setAlpha(1);
        });

        // Mercy mechanic: auto-fairy after 3 deaths
        if (GameState.deathsInSection >= 3 && !this.fairyUsed) {
            this.time.delayedCall(1000, () => {
                this.fairy.setPosition(this.player.x + 50, this.player.y - 40);
                this.fairy.setVisible(true);
                this.fairyUsed = false; // Allow fairy to be used again
            });
        }
    }

    // ---- BOSS HIT (if boss active in this scene) ----
    hitBoss() {
        // Boss logic handled in BossScene
    }

    // ---- AUTO SAVE ----
    autoSave() {
        SaveManager.save(GameState.saveSlot, GameState.toSaveData());
    }

    // ---- TUTORIAL ----
    showTutorialStep(step) {
        // Clean old prompts
        this.tutorialPrompts.forEach(p => p.destroy());
        this.tutorialPrompts = [];

        if (step === 0) {
            // Arrow pointing right
            const arrow = this.add.text(180, H - 120, 'ðŸ‘‰', { fontSize: '32px' }).setDepth(200);
            this.tweens.add({ targets: arrow, x: 220, duration: 800, yoyo: true, repeat: 3, onComplete: () => {
                arrow.destroy();
                this.tutorialStep = 1;
            }});
        }
    }

    shutdown() {
        this.scene.stop('UI');
    }
}

// ============================================================================
// UI SCENE â€” HUD overlay (runs parallel)
// ============================================================================
class UIScene extends Phaser.Scene {
    constructor() { super('UI'); }

    create() {
        // Hearts
        this.heartIcons = [];
        for (let i = 0; i < 4; i++) {
            const h = this.add.image(60 + i * 30, 40, 'heart');
            initSize(h, 22, 20);
            h.setDepth(200);
            this.heartIcons.push(h);
        }

        // Token display
        this.tokenIcon = this.add.image(W/2 - 30, 32, 'token');
        initSize(this.tokenIcon, 22, 22);
        this.tokenIcon.setDepth(200);
        this.tokenText = this.add.text(W/2 - 12, 24, '0', {
            fontSize: '22px', fill: '#ffdd44', fontStyle: 'bold',
            stroke: '#000', strokeThickness: 3
        }).setDepth(200);

        const diff = GameState.getDifficulty();
        this.tokenNeeded = this.add.text(W/2 + 20, 24, `/${diff.tokensNeeded}`, {
            fontSize: '16px', fill: '#aaaaaa', stroke: '#000', strokeThickness: 2
        }).setDepth(200);

        // Daylight meter bar
        this.daylightBg = this.add.rectangle(W/2, 8, 200, 10, 0x111133, 0.8).setDepth(199);
        this.daylightBg.setStrokeStyle(1, 0x333366);
        this.daylightBar = this.add.rectangle(W/2 - 99, 8, 198, 8, COLORS.neonCyan).setDepth(200).setOrigin(0, 0.5);

        // Sun/moon icons
        this.add.text(W/2 - 112, 2, 'â˜€', { fontSize: '12px' }).setDepth(200);
        this.add.text(W/2 + 103, 2, 'ðŸŒ™', { fontSize: '12px' }).setDepth(200);

        // Level name (fades out)
        const levelName = LEVELS[GameState.currentLevel]?.name || 'Rainbow Meadow';
        const nameText = this.add.text(W/2, H/2 - 40, levelName, {
            fontSize: '36px', fill: '#ffffff', fontStyle: 'bold',
            stroke: '#000000', strokeThickness: 4
        }).setOrigin(0.5).setDepth(300).setAlpha(0);

        this.tweens.add({
            targets: nameText, alpha: 1, duration: 500, hold: 1500,
            yoyo: true, onComplete: () => nameText.destroy()
        });

        // Listen for HUD updates from GameScene
        const gameScene = this.scene.get('Game');
        gameScene.events.on('updateHUD', this.refreshHUD, this);
    }

    refreshHUD() {
        // Hearts
        for (let i = 0; i < 4; i++) {
            this.heartIcons[i].setVisible(i < GameState.maxHearts);
            this.heartIcons[i].setAlpha(i < GameState.hearts ? 1 : 0.2);
        }

        // Pulse last heart
        if (GameState.hearts === 1) {
            if (!this.heartPulse) {
                const hrt = this.heartIcons[0];
                const hbx = hrt._bsx || hrt.scaleX, hby = hrt._bsy || hrt.scaleY;
                this.heartPulse = this.tweens.add({
                    targets: hrt, scaleX: hbx * 1.3, scaleY: hby * 1.3,
                    duration: 400, yoyo: true, repeat: -1
                });
            }
        } else if (this.heartPulse) {
            this.heartPulse.stop();
            this.heartPulse = null;
            this.heartIcons.forEach(h => h.setScale(h._bsx || h.scaleX, h._bsy || h.scaleY));
        }

        // Tokens
        this.tokenText.setText(`${GameState.tokens}`);

        // Daylight bar
        const pct = GameState.daylight / 100;
        this.daylightBar.width = 198 * pct;

        // Color shifts: green â†’ yellow â†’ red
        if (pct > 0.5) {
            this.daylightBar.fillColor = COLORS.neonCyan;
        } else if (pct > 0.2) {
            this.daylightBar.fillColor = COLORS.neonGold;
        } else {
            this.daylightBar.fillColor = COLORS.heartRed;
        }
    }
}

// ============================================================================
// PAUSE SCENE
// ============================================================================
class PauseScene extends Phaser.Scene {
    constructor() { super('Pause'); }

    create() {
        const cx = W/2, cy = H/2;

        this.add.rectangle(cx, cy, W, H, 0x000000, 0.7);

        this.add.text(cx, cy - 80, 'PAUSED', {
            fontSize: '36px', fill: '#ffffff', fontStyle: 'bold'
        }).setOrigin(0.5);

        // Resume
        this.makeButton(cx, cy - 20, 'Resume', () => {
            this.scene.resume('Game');
            this.scene.stop();
        });

        // Save & Quit
        this.makeButton(cx, cy + 40, 'Save & Quit', () => {
            SaveManager.save(GameState.saveSlot, GameState.toSaveData());
            this.scene.stop('Game');
            this.scene.stop('UI');
            this.scene.stop();
            this.scene.start('Title');
        });
    }

    makeButton(x, y, label, callback) {
        const btn = this.add.rectangle(x, y, 200, 40, COLORS.uiDark, 0.9)
            .setStrokeStyle(2, COLORS.neonCyan).setInteractive({ useHandCursor: true });
        this.add.text(x, y, label, { fontSize: '18px', fill: '#ffffff' }).setOrigin(0.5);
        btn.on('pointerdown', callback);
        btn.on('pointerover', () => btn.setStrokeStyle(2, COLORS.neonGold));
        btn.on('pointerout', () => btn.setStrokeStyle(2, COLORS.neonCyan));
    }
}

// ============================================================================
// SECRET ROOM SCENE (Wizard's Air-Aquarium)
// ============================================================================
class SecretRoomScene extends Phaser.Scene {
    constructor() { super('SecretRoom'); }

    create() {
        // Neon-blue background
        this.add.rectangle(W/2, H/2, W, H, 0x000033);

        // Floating bubble particles
        for (let i = 0; i < 40; i++) {
            const b = this.add.circle(
                Phaser.Math.Between(0, W), Phaser.Math.Between(0, H),
                Phaser.Math.Between(3, 12), COLORS.neonCyan, Phaser.Math.FloatBetween(0.05, 0.2)
            );
            this.tweens.add({
                targets: b, y: b.y - Phaser.Math.Between(50, 200), alpha: 0,
                duration: Phaser.Math.Between(3000, 6000), repeat: -1
            });
        }

        // "Fish" swimming through air
        for (let i = 0; i < 8; i++) {
            const fish = this.add.ellipse(
                Phaser.Math.Between(0, W), Phaser.Math.Between(100, H - 100),
                20, 10, Phaser.Math.RND.pick([COLORS.neonCyan, COLORS.bioGreen, COLORS.neonGold, COLORS.neonMagenta]),
                0.5
            );
            this.tweens.add({
                targets: fish, x: fish.x + Phaser.Math.Between(-200, 200),
                duration: Phaser.Math.Between(3000, 5000), yoyo: true, repeat: -1, ease: 'Sine.easeInOut'
            });
        }

        // Bonus tokens
        const bonusTokens = [];
        for (let i = 0; i < 12; i++) {
            const t = this.add.image(
                80 + (i % 6) * 140, 150 + Math.floor(i / 6) * 150, 'token'
            );
            initSize(t, 30, 30);
            t.setInteractive();

            t.on('pointerdown', () => {
                GameState.tokens++;
                // Sparkle
                for (let j = 0; j < 5; j++) {
                    const s = this.add.circle(t.x, t.y, 3, COLORS.neonGold, 0.8);
                    this.tweens.add({
                        targets: s, x: s.x + Phaser.Math.Between(-30, 30), y: s.y - 30, alpha: 0,
                        duration: 400, onComplete: () => s.destroy()
                    });
                }
                t.destroy();
            });

            // Float animation
            this.tweens.add({
                targets: t, y: t.y - 10, duration: 1200, yoyo: true, repeat: -1, ease: 'Sine.easeInOut',
                delay: i * 100
            });
        }

        // Title text
        this.add.text(W/2, 30, 'SECRET AIR-AQUARIUM', {
            fontSize: '24px', fill: '#00ffee', fontStyle: 'bold', stroke: '#000', strokeThickness: 2
        }).setOrigin(0.5);

        // Timer (30 seconds)
        let timeLeft = 30;
        const timerText = this.add.text(W/2, H - 30, `${timeLeft}`, {
            fontSize: '20px', fill: '#ffffff'
        }).setOrigin(0.5);

        this.time.addEvent({
            delay: 1000, repeat: 29,
            callback: () => {
                timeLeft--;
                timerText.setText(`${timeLeft}`);
                if (timeLeft <= 0) {
                    this.scene.resume('Game');
                    this.scene.stop();
                }
            }
        });
    }
}

// ============================================================================
// BOSS SCENE
// ============================================================================
class BossScene extends Phaser.Scene {
    constructor() { super('Boss'); }

    init(data) {
        this.levelIndex = data.level || 0;
    }

    create() {
        const ld = LEVELS[this.levelIndex];
        const diff = GameState.getDifficulty();

        // Arena background
        this.add.rectangle(W/2, H/2, W, H, COLORS.pandoraDark);

        // Ground
        const ground = this.add.rectangle(W/2, H - 20, W, 40, ld.ground);
        this.physics.add.existing(ground, true);

        // Glow line
        this.add.rectangle(W/2, H - 38, W, 3, ld.groundGlow, 0.4);

        // Platforms in arena
        const plats = this.physics.add.staticGroup();
        [{ x: 200, y: 350 }, { x: W/2, y: 280 }, { x: W - 200, y: 350 }].forEach(p => {
            const pl = this.add.rectangle(p.x, p.y, 120, 14, ld.platform);
            this.physics.add.existing(pl, true);
            plats.add(pl);
        });

        // Player
        this.player = this.physics.add.sprite(100, H - 100, GameState.activeChar);
        initSize(this.player, 42, 56);
        this.player.setDepth(10);
        this.player.body.setSize(20, 40).setOffset(6, 4);
        this.physics.add.collider(this.player, ground);
        this.physics.add.collider(this.player, plats);

        // Boss
        this.boss = this.physics.add.sprite(W - 150, H - 100, ld.bossKey);
        initSize(this.boss, 72, 72);
        this.boss.setDepth(10);
        this.physics.add.collider(this.boss, ground);
        this.boss.hp = diff.bossHP;
        this.boss.maxHP = diff.bossHP;
        this.bossPhase = 1;

        // Boss HP bar
        this.bossHPBg = this.add.rectangle(W/2, 25, 300, 16, 0x222222).setStrokeStyle(2, 0x666666);
        this.bossHPBar = this.add.rectangle(W/2 - 148, 25, 296, 12, 0x44ff44).setOrigin(0, 0.5);

        this.add.text(W/2, 45, ld.name + ' BOSS', {
            fontSize: '14px', fill: '#aaaaaa'
        }).setOrigin(0.5);

        // Input (simplified for boss arena)
        this.inputState = { moveX: 0, jump: false, action: false };
        this.attackCooldown = 0;
        this.invincible = false;

        // Joystick zone
        this.joystick = { active: false, startX: 0 };
        const jZone = this.add.rectangle(W * 0.2, H * 0.5, W * 0.4, H, 0, 0).setInteractive().setDepth(100);
        jZone.on('pointerdown', ptr => { this.joystick.active = true; this.joystick.startX = ptr.x; });
        jZone.on('pointermove', ptr => {
            if (!this.joystick.active) return;
            const dx = Phaser.Math.Clamp(ptr.x - this.joystick.startX, -40, 40);
            this.inputState.moveX = Math.abs(dx) > 8 ? dx / 40 : 0;
        });
        const endJ = () => { this.joystick.active = false; this.inputState.moveX = 0; };
        jZone.on('pointerup', endJ); jZone.on('pointerout', endJ);

        // Buttons
        const jumpBtn = this.add.circle(W - 80, H - 80, 36, 0, 0.3).setStrokeStyle(3, COLORS.neonCyan, 0.6).setInteractive().setDepth(100);
        this.add.text(W - 80, H - 80, 'â–²', { fontSize: '20px', fill: '#fff' }).setOrigin(0.5).setDepth(101);
        jumpBtn.on('pointerdown', () => this.inputState.jump = true);
        jumpBtn.on('pointerup', () => this.inputState.jump = false);

        const actBtn = this.add.circle(W - 80, H - 170, 36, 0, 0.3).setStrokeStyle(3, COLORS.neonGold, 0.6).setInteractive().setDepth(100);
        this.add.text(W - 80, H - 170, 'âš¡', { fontSize: '20px', fill: '#fff' }).setOrigin(0.5).setDepth(101);
        actBtn.on('pointerdown', () => this.inputState.action = true);
        actBtn.on('pointerup', () => this.inputState.action = false);

        // Keyboard
        this.cursors = this.input.keyboard.createCursorKeys();
        this.keys = this.input.keyboard.addKeys('A,D,W,SPACE,F');

        // Boss AI timer
        this.bossTimer = 0;
        this.bossDir = -1;

        // Hearts display
        this.heartIcons = [];
        for (let i = 0; i < 4; i++) {
            const bh = this.add.image(30 + i * 28, 25, 'heart');
            initSize(bh, 20, 18);
            bh.setDepth(200);
            this.heartIcons.push(bh);
        }
    }

    update(time, delta) {
        // Keyboard
        if (this.cursors.left.isDown || this.keys.A.isDown) this.inputState.moveX = -1;
        else if (this.cursors.right.isDown || this.keys.D.isDown) this.inputState.moveX = 1;
        else if (!this.joystick.active) this.inputState.moveX = 0;
        if (this.cursors.up.isDown || this.keys.W.isDown || this.keys.SPACE.isDown) this.inputState.jump = true;
        if (Phaser.Input.Keyboard.JustDown(this.keys.F)) this.inputState.action = true;

        // Player movement
        this.player.setVelocityX(this.inputState.moveX * 280);
        if (this.inputState.moveX < 0) this.player.setFlipX(true);
        else if (this.inputState.moveX > 0) this.player.setFlipX(false);

        if (this.inputState.jump && this.player.body.blocked.down) {
            this.player.setVelocityY(-520);
            this.inputState.jump = false;
        }

        // Attack
        if (this.attackCooldown > 0) this.attackCooldown -= delta;
        if (this.inputState.action && this.attackCooldown <= 0) {
            const dir = this.player.flipX ? -1 : 1;
            const hitX = this.player.x + dir * 45;

            // Visual
            const arc = this.add.circle(hitX, this.player.y, 35,
                GameState.activeChar === 'dante' ? COLORS.neonCyan : COLORS.neonGold, 0.4).setDepth(11);
            this.tweens.add({ targets: arc, alpha: 0, scaleX: 1.5, scaleY: 1.5, duration: 200, onComplete: () => arc.destroy() });

            // Boss hit check
            if (Phaser.Math.Distance.Between(hitX, this.player.y, this.boss.x, this.boss.y) < 80) {
                this.boss.hp--;
                this.boss.setTint(0xff0000);
                this.time.delayedCall(100, () => { if (this.boss) this.boss.clearTint(); });

                // Screen shake
                this.cameras.main.shake(100, 0.01);

                // HP bar update
                const pct = this.boss.hp / this.boss.maxHP;
                this.bossHPBar.width = 296 * pct;
                this.bossHPBar.fillColor = pct > 0.6 ? 0x44ff44 : pct > 0.3 ? 0xffaa00 : 0xff3333;

                // Phase transitions
                if (pct <= 0.6 && this.bossPhase === 1) this.bossPhase = 2;
                if (pct <= 0.3 && this.bossPhase === 2) this.bossPhase = 3;

                if (this.boss.hp <= 0) {
                    this.bossDefeated();
                    return;
                }
            }

            this.attackCooldown = 300;
            this.inputState.action = false;
        }

        // ---- BOSS AI ----
        this.bossTimer += delta;
        const speed = 100 + (this.bossPhase - 1) * 50;

        // Bounce side to side
        this.boss.setVelocityX(this.bossDir * speed);
        if (this.boss.x < 100 || this.boss.x > W - 100) this.bossDir *= -1;

        // Phase 2+: occasional charge toward player
        if (this.bossPhase >= 2 && this.bossTimer > 3000) {
            this.bossTimer = 0;
            const chargeDir = this.player.x < this.boss.x ? -1 : 1;
            this.boss.setVelocityX(chargeDir * speed * 2.5);
            this.boss.setTint(0xff4444);
            this.time.delayedCall(500, () => { if (this.boss) this.boss.clearTint(); });
        }

        // ---- BOSS SPRITE ANIMATION ----
        if (this.boss && this.boss.active) {
            const bbx = this.boss._bsx || this.boss.scaleX;
            const bby = this.boss._bsy || this.boss.scaleY;
            const agitation = this.bossPhase >= 3 ? 0.08 : this.bossPhase >= 2 ? 0.06 : 0.04;
            const breathSpeed = this.bossPhase >= 3 ? 200 : this.bossPhase >= 2 ? 280 : 350;
            this.boss.setScale(
                bbx * (1 + Math.sin(time / breathSpeed) * agitation),
                bby * (1 - Math.sin(time / breathSpeed) * agitation * 0.6)
            );
            const leanDir = this.player.x < this.boss.x ? 0.08 : -0.08;
            this.boss.setRotation(leanDir + Math.sin(time / 400) * 0.04);
            this.boss.setFlipX(this.player.x < this.boss.x);
        }

        // ---- PLAYER ANIMATION IN BOSS ARENA ----
        const pbx = this.player._bsx || this.player.scaleX;
        const pby = this.player._bsy || this.player.scaleY;
        const pvx = this.player.body.velocity.x;
        const pvy = this.player.body.velocity.y;
        const pOnGround = this.player.body.blocked.down;
        if (Math.abs(pvx) > 10 && pOnGround) {
            this.player.y += Math.sin(time / 80) * 0.3;
            this.player.setRotation(pvx > 0 ? 0.07 : -0.07);
            this.player.setScale(pbx * 1.03, pby * 0.97);
        } else if (pOnGround) {
            const b = 1 + Math.sin(time / 400) * 0.03;
            this.player.setScale(pbx * b, pby / b);
            this.player.setRotation(0);
        } else if (pvy < -100) {
            this.player.setScale(pbx / 1.1, pby * 1.1);
            this.player.setRotation(0);
        } else if (pvy > 50) {
            this.player.setScale(pbx * 1.08, pby / 1.08);
        }
        if (this.invincible) {
            this.player.setAlpha(Math.sin(time / 60) > 0 ? 0.8 : 0.3);
        }

        // Boss touching player = damage
        if (!this.invincible && Phaser.Math.Distance.Between(this.player.x, this.player.y, this.boss.x, this.boss.y) < 50) {
            GameState.hearts--;
            this.invincible = true;
            this.player.setAlpha(0.5);
            this.cameras.main.flash(200, 255, 50, 50);
            this.time.delayedCall(1500, () => { this.invincible = false; if (this.player) this.player.setAlpha(1); });

            if (GameState.hearts <= 0) {
                GameState.hearts = 3;
                this.player.setPosition(100, H - 100);
            }
        }

        // Update hearts display
        for (let i = 0; i < 4; i++) {
            this.heartIcons[i].setVisible(i < GameState.maxHearts);
            this.heartIcons[i].setAlpha(i < GameState.hearts ? 1 : 0.2);
        }
    }

    bossDefeated() {
        // Sparkle explosion!
        for (let i = 0; i < 30; i++) {
            const s = this.add.circle(this.boss.x, this.boss.y, Phaser.Math.Between(3, 8),
                Phaser.Math.RND.pick([COLORS.neonCyan, COLORS.neonGold, COLORS.neonMagenta, COLORS.white]), 0.9
            ).setDepth(20);
            this.tweens.add({
                targets: s,
                x: s.x + Phaser.Math.Between(-120, 120), y: s.y + Phaser.Math.Between(-120, 120),
                alpha: 0, scale: 0, duration: 1000, ease: 'Power2',
                onComplete: () => s.destroy()
            });
        }
        this.boss.destroy();

        // Victory text
        this.add.text(W/2, H/2, 'WORLD SAVED!', {
            fontSize: '40px', fill: '#ffdd44', fontStyle: 'bold',
            stroke: '#000', strokeThickness: 4
        }).setOrigin(0.5).setDepth(200);

        // Save and proceed
        GameState.completedWorlds.push(GameState.currentLevel);
        GameState.tokens = 0;
        GameState.hearts = 3;

        if (GameState.currentLevel < 4) {
            GameState.currentLevel++;
            GameState.checkpointX = 100;
            GameState.daylight = 100;
            SaveManager.save(GameState.saveSlot, GameState.toSaveData());

            this.time.delayedCall(3000, () => {
                this.scene.start('Game');
            });
        } else {
            // GAME COMPLETE!
            this.time.delayedCall(2000, () => {
                this.add.text(W/2, H/2 + 60, 'YOU SAVED THE DAY!', {
                    fontSize: '28px', fill: '#00ffee', fontStyle: 'bold'
                }).setOrigin(0.5).setDepth(200);

                this.time.delayedCall(4000, () => {
                    GameState.reset();
                    this.scene.start('Title');
                });
            });
        }
    }
}

// ============================================================================
// TRANSITION SCENE (placeholder for Phase 5 polish)
// ============================================================================
class TransitionScene extends Phaser.Scene {
    constructor() { super('Transition'); }
}

// ============================================================================
// PHASER CONFIG & LAUNCH
// ============================================================================
const config = {
    type: Phaser.AUTO,
    width: W,
    height: H,
    parent: 'game-container',
    backgroundColor: '#0a0a2e',
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
    },
    physics: {
        default: 'arcade',
        arcade: { gravity: { y: GRAVITY }, debug: false }
    },
    scene: [BootScene, TitleScene, GameScene, UIScene, PauseScene, SecretRoomScene, BossScene, TransitionScene],
    input: {
        activePointers: 3 // Multi-touch for joystick + buttons simultaneously
    }
};

const game = new Phaser.Game(config);

// Register service worker
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js').catch(() => {});
    });
}
</script>
</body>
</html>
